<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Python 装饰器详解 | FdxCaupona🍁</title><meta name="author" content="Fed_Dragon"><meta name="copyright" content="Fed_Dragon"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="装饰器在Python中十分有用，其本质上就是一个语法糖，使得第一个参数只能是一个函数或者类。本篇文章将详细解析装饰器的使用方法 + 为什么需要使用装饰器。 装饰器有什么用？计时函数运行时间现在假设这么一个场景，我需要计时并打印出任何一个函数的运行实现，我们可以这么实现： 1234567import timedef timer(func, *args, **kwargs):    t1 &#x3D; time">
<meta property="og:type" content="article">
<meta property="og:title" content="Python 装饰器详解">
<meta property="og:url" content="https://www.fdxblog.tk/2022/11/28/Python-%E8%A3%85%E9%A5%B0%E5%99%A8%E8%AF%A6%E8%A7%A3/index.html">
<meta property="og:site_name" content="FdxCaupona🍁">
<meta property="og:description" content="装饰器在Python中十分有用，其本质上就是一个语法糖，使得第一个参数只能是一个函数或者类。本篇文章将详细解析装饰器的使用方法 + 为什么需要使用装饰器。 装饰器有什么用？计时函数运行时间现在假设这么一个场景，我需要计时并打印出任何一个函数的运行实现，我们可以这么实现： 1234567import timedef timer(func, *args, **kwargs):    t1 &#x3D; time">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.fdxblog.tk/img/cover1.webp">
<meta property="article:published_time" content="2022-11-28T10:23:30.000Z">
<meta property="article:modified_time" content="2022-12-05T04:12:28.179Z">
<meta property="article:author" content="Fed_Dragon">
<meta property="article:tag" content="Python">
<meta property="article:tag" content="装饰器">
<meta property="article:tag" content="functools">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.fdxblog.tk/img/cover1.webp"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://www.fdxblog.tk/2022/11/28/Python-%E8%A3%85%E9%A5%B0%E5%99%A8%E8%AF%A6%E8%A7%A3/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Python 装饰器详解',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-12-05 12:12:28'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><style>@font-face{font-family:'zhuziawan';font-style:normal;font-weight:400;src:url(https://conf.totoro.pub/fonts/zhuziawan/zhuziawan.woff2) format("woff2")}</style><meta name="generator" content="Hexo 6.3.0"></head><body><link rel="stylesheet" href="/css/barber-shop.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.webp" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">4</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa-solid fa-newspaper"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/cover1.webp'); backdrop-filter: blur(2px)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">FdxCaupona🍁</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa-solid fa-newspaper"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Python 装饰器详解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-11-28T10:23:30.000Z" title="发表于 2022-11-28 18:23:30">2022-11-28</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-12-05T04:12:28.179Z" title="更新于 2022-12-05 12:12:28">2022-12-05</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Python 装饰器详解"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>装饰器在Python中十分有用，其本质上就是一个语法糖，使得第一个参数只能是一个函数或者类。本篇文章将详细解析装饰器的使用方法 + 为什么需要使用装饰器。</p>
<h2 id="装饰器有什么用？"><a href="#装饰器有什么用？" class="headerlink" title="装饰器有什么用？"></a>装饰器有什么用？</h2><h3 id="计时函数运行时间"><a href="#计时函数运行时间" class="headerlink" title="计时函数运行时间"></a>计时函数运行时间</h3><p>现在假设这么一个场景，我需要计时并打印出任何一个函数的运行实现，我们可以这么实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">timer</span>(<span class="params">func, *args, **kwargs</span>):</span><br><span class="line">    t1 = time.perf_counter()</span><br><span class="line">    func(*args, **kwargs)</span><br><span class="line">    t2 = time.perf_counter()</span><br><span class="line">    <span class="built_in">print</span>(t2 - t1)</span><br></pre></td></tr></table></figure>
<p>创建一个<code>timer</code>函数，参数列表是一个函数和该函数的参数列表。然后在函数运行前后获取时间，并打印差值。<br>要使用这个函数也很简单，就像这样：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sleep_n</span>(<span class="params">n</span>):</span><br><span class="line">    time.sleep(n)</span><br><span class="line"></span><br><span class="line">timer(sleep_n, <span class="number">5</span>)    <span class="comment"># 5.000540600000022</span></span><br></pre></td></tr></table></figure>
<p>但是这样很丑，每一次计时都需要显示调用<code>timer</code>函数，如果有一种方法可以让每一次调用<code>sleep_n(5)</code>都输出调用时间就好了。改进了之后的代码可能长这样：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">timer</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        t1 = time.perf_counter()</span><br><span class="line">        func(*args, **kwargs)</span><br><span class="line">        t2 = time.perf_counter()</span><br><span class="line">        <span class="built_in">print</span>(t2 - t1)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure>
<p>这次<code>timer</code>函数只接受一个Callable对象，使得<code>wrapper</code>函数可以通过闭包读取到<code>func</code>。值得注意的是<code>wrapper</code>函数会有很多份——每一次调用<code>timer</code>都会新创建这个函数，也就是说每一次返回的值是不同的函数对象而非同一份（<code>timer(f) is not timer(f)</code>）<br>更改了<code>timer</code>，自然也需要更改使用方法，这次先搭建好了<code>sleep_n</code>函数之后把函数直接传给<code>timer</code>再赋值给<code>sleep_n</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sleep_n</span>(<span class="params">n</span>):</span><br><span class="line">    time.sleep(n)</span><br><span class="line"></span><br><span class="line">sleep_n = timer(sleep_n)</span><br><span class="line">sleep_n(<span class="number">5</span>)    <span class="comment"># 5.0063890999999785</span></span><br></pre></td></tr></table></figure>
<p>这就导致了这个函数虽然还叫<code>sleep_n</code>，但是其指向的对象却被改成了这个<code>wrapper</code>函数，在调用<code>sleep_n(5)</code>的时候实际上是调用了<code>timer</code>函数内<code>wrapper</code>指向的函数对象。不严谨的说，就是调用了<code>wrapper(5)</code>，所以打印出来了时长。<br>但是这么写还是很丑，需要一种方法专门做到创建(<code>sleep_n</code>)函数，调用目标(<code>timer</code>)函数，然后再赋值会原来的函数(<code>sleep_n = timer(sleep_n)</code>)，而装饰器就由此而生了，上面的代码用装饰器的写法可以这么写：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@timer</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sleep_n</span>(<span class="params">n</span>):</span><br><span class="line">    time.sleep(n)</span><br><span class="line"></span><br><span class="line">sleep_n(<span class="number">1</span>)    <span class="comment"># 1.0079503999995723</span></span><br></pre></td></tr></table></figure>
<p>所以不难看出来，装饰器(<code>@xxx def x</code>)的效果就是<code>x = xxx(x)</code>，和上面说的一样，只是一个语法糖来简化”create, pipe, assign”这三个步骤的。事实上上面两个代码块里关于<code>sleep_n</code>函数的处理是完全等价的。</p>
<h3 id="给函数添加属性"><a href="#给函数添加属性" class="headerlink" title="给函数添加属性"></a>给函数添加属性</h3><p>既然装饰器需要一个函数作为参数输入，那我们自然也可以修改或者增加这个函数的属性，比如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">stamp</span>(<span class="params">func</span>):</span><br><span class="line">    func.stamped = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> func</span><br><span class="line"></span><br><span class="line"><span class="meta">@stamp</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> test.stamped:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;添加属性成功！&quot;</span>)    <span class="comment"># 添加属性成功！</span></span><br></pre></td></tr></table></figure>
<p>在这个例子里<code>@stamp</code>装饰器返回的还是原来那个函数，只是动态添加了一个属性<code>stamped</code>，这个属性可以用在判断内。这个”黑魔法“在抽象类ABC中有广泛使用，详见<a href="/2022/11/18/Python-Metaclass%E4%B8%8E%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B/">元类与使用案例</a>。</p>
<h2 id="更高级的装饰器"><a href="#更高级的装饰器" class="headerlink" title="更高级的装饰器"></a>更高级的装饰器</h2><h3 id="functools-wraps装饰器装饰装饰器"><a href="#functools-wraps装饰器装饰装饰器" class="headerlink" title="functools.wraps装饰器装饰装饰器(?)"></a><code>functools.wraps</code>装饰器装饰装饰器(?)</h3><p>还是以前面的<code>timer</code>装饰器举例子，假设我现在有这么一个函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">timer</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        t1 = time.perf_counter()</span><br><span class="line">        ret = func(*args, **kwargs)</span><br><span class="line">        t2 = time.perf_counter()</span><br><span class="line">        <span class="built_in">print</span>(t2 - t1)</span><br><span class="line">        <span class="keyword">return</span> ret    <span class="comment"># 确保将返回值再返回回去</span></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@timer</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;将两个参数相加&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(add(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line"><span class="comment"># 用时：2.9000002541579306e-06</span></span><br><span class="line"><span class="comment"># 输出：3</span></span><br></pre></td></tr></table></figure>
<p>现在问题出现了，由于<code>timer</code>装饰器返回的<code>wrapper</code>函数替代了<code>add</code>函数（虽然还叫add），尝试去读取docstring和其他一些元信息的时候会变成其他的信息。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@timer</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;将两个参数相加&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(add.__doc__, add.__name__)    <span class="comment"># None wrapper</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;将两个参数相加&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(add.__doc__, add.__name__)    <span class="comment"># 将两个参数相加 add</span></span><br></pre></td></tr></table></figure>
<p>怎么解决这个问题呢？其实Python内置的<code>functools.wraps</code>装饰器就可以解决这个问题，下面是使用方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">timer</span>(<span class="params">func</span>):</span><br><span class="line"><span class="meta">    @functools.wraps(<span class="params">func</span>)    </span><span class="comment"># ”包装了“func函数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        t1 = time.perf_counter()</span><br><span class="line">        ret = func(*args, **kwargs)</span><br><span class="line">        t2 = time.perf_counter()</span><br><span class="line">        <span class="built_in">print</span>(t2 - t1)</span><br><span class="line">        <span class="keyword">return</span> ret    <span class="comment"># 确保将返回值再返回回去</span></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure>
<p><code>functools.wraps</code>会将传进去的<code>func</code>函数的元信息（包括<code>__module__</code>, <code>__name__</code>, <code>__qualname__</code>, <code>__annotations__</code>, 和 <code>__doc__</code>）替换掉<code>wrapper</code>函数的这些属性，顺便将<code>func.__dict__</code>（实例字典）也同步到<code>wrapper</code>上，所以下面的代码得以成立：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">stamp</span>(<span class="params">func</span>):</span><br><span class="line">    func.__stamped__ = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> func</span><br><span class="line"></span><br><span class="line"><span class="meta">@timer</span></span><br><span class="line"><span class="meta">@stamp</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="built_in">print</span>(add.__stamped__)    <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>)    <span class="comment"># 1.2299999980314169e-05</span></span><br></pre></td></tr></table></figure>
<p>上面这个程序可以正常运行，因为：</p>
<ol>
<li>首先多个装饰器装饰一个函数会从下往上套，根据语法糖<code>@timer @stamp def add</code>等同于<code>add = timer(stamp(add))</code>，所以会先进行<code>stamp(add)</code></li>
<li>在<code>stamp</code>装饰器内将<code>__stamped__</code>属性赋值，而这个属性是存在于被传进来的<code>func</code>（也就是<code>add</code>）的实例字典的，也就是说这个阶段<code>add.__dict__</code>等于<code>&#123;&#39;__stamped__&#39;: True&#125;</code></li>
<li><code>stamp(func)</code>返回了修改过的<code>func</code>函数，这个函数又作为第一个参数传给<code>timer</code>装饰器</li>
<li><code>timer</code>装饰器内的<code>wrapper</code>函数由于使用了<code>functools.wraps</code>装饰器，所以它复制了前面提到的元信息，包括其实例字典中同步了<code>__stamp__</code>属性。这个<code>wrapper</code>函数被返回并赋值给<code>add</code>变量</li>
<li>调用<code>add(1, 2)</code>，开始计时并运行<code>stamp(add)</code>传回来的函数，这个运行回来的函数会去先<code>LOAD_GLOBAL</code>找到这个<code>add</code>函数，由于在全局命名空间内<code>add</code>已经被重新赋值为<code>wrapper</code>函数，所以会从这个<code>wrapper</code>函数内找<code>__stamp__</code>这个属性。</li>
<li>在实例字典内找到了这个属性，所以可以打印出来<code>True</code></li>
<li>完成计时打印出来时间</li>
</ol>
<p>值得注意的是<code>LOAD_GLOBAL</code>并不是这个函数可以运行的主要原因。由于这个函数定义在全局空间内所以他会使用全局搜索，而如果在类体内则会使用<code>LOAD_ATTR</code>。但是这些都不影响，因为无论在什么命名空间搜索<code>add</code>函数，都会搜索到这个<code>wrapper</code>，因为其语法糖的特性会在当前命名空间内重新赋值并覆盖掉原来的那个函数。</p>
<h3 id="多个装饰器嵌套"><a href="#多个装饰器嵌套" class="headerlink" title="多个装饰器嵌套"></a>多个装饰器嵌套</h3><p>上面的例子其实已经很明确了，多个装饰器嵌套的规律就是从下往上运算，比如下面的代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">dec</span>(<span class="params">f</span>):</span><br><span class="line">    <span class="built_in">print</span>(f.__name__)</span><br><span class="line">    f.__name__ = f.__name__[:-<span class="number">1</span>] + <span class="built_in">str</span>(<span class="built_in">int</span>(f.__name__[-<span class="number">1</span>]) + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> f</span><br><span class="line"></span><br><span class="line"><span class="meta">@dec    </span><span class="comment"># func2</span></span><br><span class="line"><span class="meta">@dec    </span><span class="comment"># func1</span></span><br><span class="line"><span class="meta">@dec    </span><span class="comment"># func0</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func0</span>():</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(func0.__name__)    <span class="comment"># func3</span></span><br></pre></td></tr></table></figure>
<p>这段代码的作用就是打印<code>f</code>的名字，然后把最后一位数字加一并返回这个函数。上面装饰器的语法糖与下面写出来的版本无异，酷似elixer的<code>|&gt;</code>运算符，将结果依次传送到函数内加工：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func0</span>():</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">func0 = dec(func0)    <span class="comment"># func0</span></span><br><span class="line">func0 = dec(func0)    <span class="comment"># func1</span></span><br><span class="line">func0 = dec(func0)    <span class="comment"># func2</span></span><br><span class="line"><span class="built_in">print</span>(func0.__name__)    <span class="comment"># func3</span></span><br></pre></td></tr></table></figure>
<p>注意这里为了追求严谨性一定是分开写的，因为每装饰一次都会赋值给<code>func0</code>一次，而不是下面这种one liner:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func0</span>(): ...</span><br><span class="line">func0 = dec(dec(dec(func0)))</span><br></pre></td></tr></table></figure>

<h3 id="装饰器传参"><a href="#装饰器传参" class="headerlink" title="装饰器传参"></a>装饰器传参</h3><p>还是以我们的<code>timer</code>装饰器举例子，如果我们想控制传进去的参数的运行次数并记录时间，该怎么办呢？我们可以像<code>functools.wraps</code>装饰器一样要求传进来一个参数，而<code>timer</code>因为要接受这个参数所以必须在最外层再嵌套一个函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">timer</span>(<span class="params">*, epochs</span>):</span><br><span class="line">    <span class="keyword">assert</span> epochs &gt; <span class="number">0</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">actual_decorator</span>(<span class="params">func</span>):</span><br><span class="line"><span class="meta">        @functools.wraps(<span class="params">func</span>)</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">            t1 = time.perf_counter()</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(epochs):</span><br><span class="line">                ret = func(*args, **kwargs)</span><br><span class="line">            t2 = time.perf_counter()</span><br><span class="line">            <span class="built_in">print</span>(t2 - t1)</span><br><span class="line">            <span class="keyword">return</span> ret  <span class="comment"># 确保将返回值再返回回去</span></span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> actual_decorator</span><br></pre></td></tr></table></figure>
<p>要使用起来，就必须得在<code>@timer</code>时传一个参数代表运行多少次这个函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@timer(<span class="params">epochs=<span class="number">1_0000_0000</span></span>)    </span><span class="comment"># 8.325460200001544 Python真的慢</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"><span class="built_in">print</span>(add(<span class="number">1</span>, <span class="number">2</span>))    <span class="comment"># 3</span></span><br></pre></td></tr></table></figure>
<p>下面是这个函数的解析：</p>
<ol>
<li>无论它传参也好不传参也好，现根据装饰器的语法糖定义改写成正常的形式<blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a, b</span>):</span><br><span class="line">  <span class="keyword">return</span> a + b</span><br><span class="line">add = timer(epoches=<span class="number">1_0000_0000</span>)(add)</span><br><span class="line"><span class="built_in">print</span>(add(<span class="number">1</span>, <span class="number">2</span>))</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li>而最重要的一行就是<code>timer(epochs=1_0000_0000)(add)</code>，根据运算法则，先计算<code>timer(epochs=1_0000_0000)</code>。而这个函数直接返回了<code>actual_decorator</code></li>
<li>所以原代码可以被“简写”成<code>actual_decorator(add)</code>，而这个形式和只使用<code>@actual_decorator</code>无异，只是<code>epochs</code>被闭包保存了而已</li>
<li>将<code>actual_decorator</code>的返回值<code>wrapper</code>赋值给<code>add</code>，现在<code>add</code>可以通过闭包找到属于<code>timer</code>的<code>epochs</code>和属于<code>actual_decorator</code>的<code>func</code></li>
<li>调用<code>add(1, 2)</code>，打印出来运行时间和结果3</li>
</ol>
<h3 id="类也可以被装饰"><a href="#类也可以被装饰" class="headerlink" title="类也可以被装饰"></a>类也可以被装饰</h3><p>注意这里的类是被装饰的，而不是装饰器本身。类被装饰与函数的唯一不同是传进装饰器的第一个参数是这个类本身而不是函数罢了，语法糖是一样的。下面的例子根据<code>__gt__</code>动态生产能了<code>__lt__</code>等大小比较方法:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">generate_lt</span>(<span class="params">cls</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">hasattr</span>(cls, <span class="string">&quot;__gt__&quot;</span>):</span><br><span class="line">        <span class="keyword">raise</span></span><br><span class="line">    cls.__lt__ = <span class="keyword">lambda</span> self, other: <span class="keyword">not</span> self &gt; other</span><br><span class="line">    <span class="keyword">return</span> cls</span><br><span class="line"></span><br><span class="line"><span class="meta">@generate_lt</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyInt</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, value</span>):</span><br><span class="line">        self.value = value</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__gt__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">return</span> self.value &gt; other</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(MyInt(<span class="number">5</span>) &lt; <span class="number">3</span>)    <span class="comment"># False</span></span><br><span class="line"><span class="built_in">print</span>(MyInt.__lt__)    <span class="comment"># &lt;function generate_lt.&lt;locals&gt;.&lt;lambda&gt; at 0x0000023D6988EB90&gt;</span></span><br></pre></td></tr></table></figure>
<p>这算是一个简便版的<code>functools.total_ordering</code>，其可以通过一个比较大小方法和一个等于方法生成所有的大小比较方法。<br>在这个装饰器内还可以生成一个类然后返回，替换掉用户的类，比如<code>dataclass</code>就是这么做的，这里有超级简化过的版本：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> types <span class="keyword">import</span> Function</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_setter</span>(<span class="params">name, type_guard</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">s</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">assert</span> <span class="built_in">isinstance</span>(other, type_guard)</span><br><span class="line">        <span class="built_in">setattr</span>(self, <span class="string">f&quot;__<span class="subst">&#123;name&#125;</span>&quot;</span>, other)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_getter</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">lambda</span> self: <span class="built_in">getattr</span>(self, <span class="string">f&quot;__<span class="subst">&#123;name&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">simple_dataclass</span>(<span class="params">cls</span>):</span><br><span class="line">    namespace = &#123;&#125;</span><br><span class="line">    init = <span class="string">f&quot;def __init__(self, <span class="subst">&#123;<span class="string">&#x27;, &#x27;</span>.join(x <span class="keyword">for</span> x <span class="keyword">in</span> cls.__annotations__)&#125;</span>):\n&quot;</span></span><br><span class="line">    <span class="keyword">for</span> name, type_ <span class="keyword">in</span> cls.__annotations__.items():</span><br><span class="line">        namespace[<span class="string">f&quot;get_<span class="subst">&#123;name&#125;</span>&quot;</span>] = generate_getter(name)    </span><br><span class="line">        <span class="comment"># 这里不能直接用lambda，比如这样：</span></span><br><span class="line">        <span class="comment"># namespace[f&quot;get_&#123;name&#125;&quot;] = lambda self: getattr(self, f&quot;__&#123;name&#125;&quot;)</span></span><br><span class="line">        <span class="comment"># 闭包搜索的时候(LOAD_DEREF)会找到循环最后一个name，而不是现在定义的这个</span></span><br><span class="line">        <span class="comment"># 换言之所有的 getter 都会获取到最后一次循环的name</span></span><br><span class="line">        namespace[<span class="string">f&quot;set_<span class="subst">&#123;name&#125;</span>&quot;</span>] = generate_setter(name, type_)</span><br><span class="line">        init += <span class="string">f&quot;    self.set_<span class="subst">&#123;name&#125;</span>(<span class="subst">&#123;name&#125;</span>)\n&quot;</span></span><br><span class="line">    code = <span class="built_in">compile</span>(init, cls.__module__, <span class="string">&quot;exec&quot;</span>)</span><br><span class="line">    namespace[<span class="string">&quot;__init__&quot;</span>] = FunctionType(</span><br><span class="line">        code.co_consts[<span class="number">0</span>], <span class="built_in">globals</span>(), <span class="string">&quot;__init__&quot;</span>  <span class="comment"># 这个才是函数的code object，code本身是利用这个搭建函数</span></span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">type</span>(cls.__qualname__, cls.__bases__, namespace)</span><br></pre></td></tr></table></figure>
<p>这里使用了一些黑魔法:</p>
<ul>
<li>对<code>type</code>三参数创建类不了解的同学可以看这里：<a href="/2022/11/18/Python-Metaclass%E4%B8%8E%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B/">Python元类+使用案例</a></li>
<li>这里使用了 FunctionType 直接创建函数实例而非使用<code>def</code>关键字，如果不了解的话可以看这里：<a href=""><code>def</code>关键字竟然是语法糖？Python Code Object详解</a></li>
</ul>
<p>要使用这个简单数据类也很简单，只需要把写好类型的类挂上装饰器，就可以自动生成<code>setter</code>，<code>getter</code>，还有<code>__init__</code>方法啦（虽然这种<code>getter</code> &#x2F; <code>setter</code>应该用<code>property</code>更好）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@simple_dataclass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    hi: <span class="built_in">str</span></span><br><span class="line">    n: <span class="built_in">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># A()    # TypeError: __init__() missing 2 required positional arguments: &#x27;hi&#x27; and &#x27;n&#x27;</span></span><br><span class="line"><span class="comment"># A(1, &quot;234&quot;)    # AssertionError</span></span><br><span class="line"><span class="comment"># print(A(&quot;234&quot;, 2).hi)    # AttributeError: &#x27;A&#x27; object has no attribute &#x27;hi&#x27;</span></span><br><span class="line">a = A(<span class="string">&quot;234&quot;</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(a.__hi)    <span class="comment"># 234 注：运行时动态设置的属性不会变成 _A__hi</span></span><br><span class="line"><span class="built_in">print</span>(a.get_hi())    <span class="comment"># 234</span></span><br><span class="line">a.set_hi(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(a.get_hi())    <span class="comment"># hello</span></span><br></pre></td></tr></table></figure>

<h3 id="类也可以被当作装饰器"><a href="#类也可以被当作装饰器" class="headerlink" title="类也可以被当作装饰器"></a>类也可以被当作装饰器</h3><p>根据语法糖的特性，被装饰的东西只是作为第一个参数被传进<code>__call__</code>了而已，所以用一个类装饰就相当于以被装饰的结构体作为第一个参数实例化这个类。举个例子，下面的代码可能看起来很离谱，但是拆解开来就很正常了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@str</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hi</span>():</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line"><span class="built_in">print</span>(hi, <span class="built_in">type</span>(hi))    <span class="comment"># &lt;function hi at %p&gt; &lt;class &#x27;str&#x27;&gt;</span></span><br></pre></td></tr></table></figure>
<p>把这个语法糖复原成它原来的样子，就一目了然了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">hi</span>(): ...</span><br><span class="line">hi = <span class="built_in">str</span>(hi)</span><br><span class="line"><span class="built_in">print</span>(hi, <span class="built_in">type</span>(hi))</span><br></pre></td></tr></table></figure>
<p>所以说上面的装饰器实际上做的就是把<code>hi</code>作为第一个参数传进<code>str</code>的构造器然后再赋值会<code>hi</code>而已。<br>那么这个有什么用呢？<code>functools.wraps</code>实际上就是使用了这种黑魔法实现的。</p>
<h2 id="装饰器使用鉴赏"><a href="#装饰器使用鉴赏" class="headerlink" title="装饰器使用鉴赏"></a>装饰器使用鉴赏</h2><h3 id="装饰器装饰装饰器之functools-wraps"><a href="#装饰器装饰装饰器之functools-wraps" class="headerlink" title="装饰器装饰装饰器之functools.wraps"></a>装饰器装饰装饰器之<code>functools.wraps</code></h3><p>这个装饰器很有意思，它既包括了装饰器传参，也包括了类装饰器。其作用就是在<code>wrapper</code>函数包装<code>func</code>函数的时候将<code>func</code>的<code>assigned</code>里所有的属性遍历赋值给<code>wrapper</code>(包括 <code>__module__</code>, <code>__annotation__</code>等)，并遍历<code>updated</code>里的属性名称，以<code>func</code>的该属性更新<code>wrapper</code>的属性，也就是说<code>updated</code>里的属性必须支持<code>update</code>方法。下面是稍作修改过的源代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">update_wrapper</span>(<span class="params">wrapper, wrapped, assigned, updated</span>):</span><br><span class="line">    <span class="keyword">for</span> attr <span class="keyword">in</span> assigned:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            value = <span class="built_in">getattr</span>(wrapped, attr)</span><br><span class="line">        <span class="keyword">except</span> AttributeError:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="built_in">setattr</span>(wrapper, attr, value)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> attr <span class="keyword">in</span> updated:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            value = <span class="built_in">getattr</span>(wrapped, attr)</span><br><span class="line">        <span class="keyword">except</span> AttributeError:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="built_in">getattr</span>(wrapper, attr).update(value)</span><br><span class="line"></span><br><span class="line">    wrapper.__wrapped__ = wrapped    <span class="comment"># 可以访问到原函数</span></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_wraps</span>(<span class="params"></span></span><br><span class="line"><span class="params">    func,</span></span><br><span class="line"><span class="params">    assigned=(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="params">        <span class="string">&quot;__module__&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="params">        <span class="string">&quot;__name__&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="params">        <span class="string">&quot;__qualname__&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="params">        <span class="string">&quot;__doc__&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="params">        <span class="string">&quot;__annotations__&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="params">    </span>),  <span class="comment"># 复制这些属性到 func 上</span></span></span><br><span class="line"><span class="params">    updated=(<span class="params"><span class="string">&quot;__dict__&quot;</span>,</span>),  <span class="comment"># 更新 func 的这些属性到下面装饰的函数上</span></span></span><br><span class="line"><span class="params"></span>):</span><br><span class="line">    <span class="keyword">return</span> functools.partial(update_wrapper, wrapped=func, assigned=assigned, updated=updated)</span><br></pre></td></tr></table></figure>
<p>还是老规矩，我们借着一个装饰器看看它是怎么工作的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">my_decorator</span>(<span class="params">func</span>):</span><br><span class="line"><span class="meta">    @my_wraps(<span class="params">func</span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;开始运行函数<span class="subst">&#123;func.__qualname__&#125;</span>！&quot;</span>)</span><br><span class="line">        ret = func(*args, **kwargs)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;结束运行函数<span class="subst">&#123;func.__qualname__&#125;</span>！&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"><span class="meta">@my_decorator</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">a</span>(<span class="params">x: <span class="built_in">int</span> = <span class="number">1</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;this is a doc&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<ol>
<li>按照程序运行顺序，先是<code>@my_decorator</code>装饰<code>a</code>，简化语法糖，将程序变成这样：<blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">a</span>(<span class="params">x: <span class="built_in">int</span> = <span class="number">1</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;this is a doc&quot;&quot;&quot;</span></span><br><span class="line">a = my_decorator(a)</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li>在<code>my_decorator</code>内部的第一件事就是装饰这个<code>inner</code>函数，一样的简化语法糖<blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">my_decorator</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;开始运行函数<span class="subst">&#123;func.__qualname__&#125;</span>！&quot;</span>)</span><br><span class="line">        ret = func(*args, **kwargs)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;结束运行函数<span class="subst">&#123;func.__qualname__&#125;</span>！&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line">    inner = my_wraps(func)(inner)</span><br><span class="line">    <span class="keyword">return</span> inner</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li>根据运算优先级，在创建完<code>inner</code>函数之后应该先运行<code>my_wraps(func)</code>，将他返回的一大串都替换进来：<blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">my_decorator</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;开始运行函数<span class="subst">&#123;func.__qualname__&#125;</span>！&quot;</span>)</span><br><span class="line">        ret = func(*args, **kwargs)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;结束运行函数<span class="subst">&#123;func.__qualname__&#125;</span>！&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line">    <span class="comment"># 这里 functools.partial 是一个类！不是一个函数！所以是一个 functools_object.__call__(inner)</span></span><br><span class="line">    inner = functools.partial(update_wrapper, wrapped=func, assigned=assigned, updated=updated)(inner)</span><br><span class="line">    <span class="keyword">return</span> inner</span><br></pre></td></tr></table></figure>
<p><code>functools.partial</code>是干什么的呢？它实际上就是一个类，这个类在初始化的时候第一个参数一定是一个函数，而后面可以给任意量的普通参数和关键字参数。实例化之后，如果<code>__call__</code>方法被调用，就会调用传进去的函数，并将参数列表补上。参数列表会先使用实例化传进去的位置参数，然后使用调用时的位置参数，最后再加上所有的关键字参数，比如：</p>
<blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">*args, hi=<span class="string">&quot;hi&quot;</span>, **kwargs</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;hi=&#125;</span>, <span class="subst">&#123;args=&#125;</span>, <span class="subst">&#123;kwargs=&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">partial = functools.partial(foo, <span class="string">&quot;创建时传的位置参数&quot;</span>, hi=<span class="string">&quot;hello&quot;</span>, 创建时传的关键字参数=<span class="number">123</span>)</span><br><span class="line">partial(<span class="string">&quot;调用时传的位置参数&quot;</span>)    <span class="comment"># hi=&#x27;hello&#x27;, args=(&#x27;创建时传的位置参数&#x27;, &#x27;调用时传的位置参数&#x27;), kwargs=&#123;&#x27;创建时传的关键字参数&#x27;: 123&#125;</span></span><br></pre></td></tr></table></figure>
<p>这里<code>partial</code>提供了<strong>部分</strong>参数，而再调用(<code>__call__</code>)的时候则会将参数列表按照刚才说过的顺序补齐</p>
</blockquote>
</blockquote>
</li>
<li>创建好了<code>partial</code>对象之后，调用并传进去<code>inner</code>函数，根据<code>partial</code>的运行规则，所有那一大行都相当于<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update_wrapper(inner, wrapped=func, assigned=assigned, updated=updated)</span><br></pre></td></tr></table></figure>
那么只需要运行<code>update_wrapper</code>，将结果赋值给<code>inner</code>然后返回<code>inner</code>就好了</li>
<li>在<code>update_wrapper</code>内所做的就是遍历<code>assigned</code>里的属性名称，将原来函数的对应属性赋值给传进去的<code>inner</code>，也就是替换掉<code>__annotations__</code>之类的元信息；然后遍历<code>updated</code>里的属性名称，使用原来函数的对应属性更新传进去的<code>inner</code>，这也就要求了这个属性必须支持<code>update</code>方法，而不传任何其他参数的情况下更新的只有实例字典(<code>__dict__</code>)属性；最后再赋值<code>__wrapper__</code>属性，引用一下被包装的函数</li>
<li><code>my_wraps</code>装饰器结束，返回修改过的<code>wrapper</code>函数</li>
</ol>
<p>注意到<code>my_wraps</code>其实还可以指定<code>assigned</code>和<code>updated</code>参数，所以让<code>my_wraps</code>装饰器不去赋值<code>__doc__</code>属性也是完全可以的，只需要传一个除了该参数名的元组就可以了。</p>
<h3 id="空间换时间，lru-cahce"><a href="#空间换时间，lru-cahce" class="headerlink" title="空间换时间，lru_cahce!"></a>空间换时间，<code>lru_cahce</code>!</h3><p>为了简便原因和讲解装饰器的主旨，我会讲解<code>lru_cahce</code>的简便版本，也就是没有lru的<code>cache</code>装饰器并经过修改。这个装饰器所做的就是将传进来的参数和结果存到一个字典内，如果有同样的参数被传到函数内，就不会运行函数体而是直接返回结果。这可以大大增加需要重复计算或者递归函数的运行速度，虽然在空间上消耗不小。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="meta">@functools.cache</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cached_fib</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">assert</span> n &gt; <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> cached_fib(n - <span class="number">1</span>) + cached_fib(n - <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fib</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">assert</span> n &gt; <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">t1 = time.perf_counter()</span><br><span class="line">cached_fib(<span class="number">400</span>)</span><br><span class="line">t2 = time.perf_counter()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;cached_fib: <span class="subst">&#123;t2 - t1&#125;</span>&quot;</span>)    <span class="comment"># 0.0004117000003134308</span></span><br><span class="line"></span><br><span class="line">t1 = time.perf_counter()</span><br><span class="line">fib(<span class="number">37</span>)</span><br><span class="line">t2 = time.perf_counter()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;fib: <span class="subst">&#123;t2 - t1&#125;</span>&quot;</span>)    <span class="comment"># 3.925901200000226 100我跑了五分钟也没跑出来</span></span><br></pre></td></tr></table></figure>
<p>可以看到有了<code>cache</code>装饰器之后速度甚至可以做到毫秒级，这里用400是因为在大就会爆栈了。接下来我会用简化过的代码来展示<code>cache</code>的大致工作流程：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">_HashedSeq</span>(<span class="title class_ inherited__">list</span>):</span><br><span class="line">    __slots__ = <span class="string">&quot;hashvalue&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, tup</span>):</span><br><span class="line">        self[:] = tup</span><br><span class="line">        self.hashvalue = <span class="built_in">hash</span>(tup)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__hash__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.hashvalue</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CacheWrapper</span>:</span><br><span class="line">    sentinel = <span class="built_in">object</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, f</span>):</span><br><span class="line">        self.f = f</span><br><span class="line">        self.cache = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, *args, **kwargs</span>):</span><br><span class="line">        key = self.make_key(args, kwargs)</span><br><span class="line">        result = self.cache.get(key, self.sentinel)</span><br><span class="line">        <span class="keyword">if</span> result <span class="keyword">is</span> <span class="keyword">not</span> self.sentinel:</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        result = self.f(*args, **kwargs)</span><br><span class="line">        self.cache[key] = result</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">make_key</span>(<span class="params">args, kwds, kwd_mark=(<span class="params"><span class="built_in">object</span>(<span class="params"></span>),</span>), fasttypes=&#123;<span class="built_in">int</span>, <span class="built_in">str</span>&#125;</span>):</span><br><span class="line">        key = args</span><br><span class="line">        <span class="keyword">if</span> kwds:</span><br><span class="line">            key += kwd_mark  <span class="comment"># 把位置参数和关键字参数区分开，因为有可能位置参数传 dict_item</span></span><br><span class="line">            <span class="keyword">for</span> item <span class="keyword">in</span> kwds.items():</span><br><span class="line">                key += item</span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">len</span>(key) == <span class="number">1</span> <span class="keyword">and</span> <span class="built_in">type</span>(key[<span class="number">0</span>]) <span class="keyword">in</span> fasttypes:</span><br><span class="line">            <span class="comment"># 如果只有一个 str 或者 int 就返回这个对象</span></span><br><span class="line">            <span class="keyword">return</span> key[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> _HashedSeq(key)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cache</span>(<span class="params">f</span>):</span><br><span class="line">    wrapper = CacheWrapper(f)</span><br><span class="line">    <span class="keyword">return</span> functools.update_wrapper(wrapper, f)</span><br><span class="line">    </span><br><span class="line"><span class="meta">@cache</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cached_fib</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">assert</span> n &gt; <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> cached_fib(n - <span class="number">1</span>) + cached_fib(n - <span class="number">2</span>)</span><br><span class="line">    </span><br><span class="line"><span class="built_in">print</span>(cached_fib(<span class="number">4</span>))    <span class="comment"># 3</span></span><br></pre></td></tr></table></figure>
<p>老样子，一步一步看这个<code>cache</code>装饰器是怎么工作的：</p>
<ol>
<li>化简装饰器，<code>cached_fib = functools.update_wrapper(CacheWrapper(f), f)</code></li>
<li>外面那一圈<code>update_wrapper</code>就是上面<code>functools.wraps</code>里面的，只是把一些元信息赋值给<code>f</code>而已，所以可以忽略掉，对函数的运行没有任何影响，也就是说<code>CacheWrapper(f)</code>是最重要的部分</li>
<li>也就是说，<code>cached_fib</code>现在是一个<code>CacheWrapper</code>的对象</li>
<li>运行<code>cached_fib(3)</code>，进入<code>CacheWrapper.__call__</code>，在里面先通过传进去的<code>args</code>和<code>kwargs</code>，如果只有一个参数且类型为<code>str</code>或者<code>int</code>则原封不动返回，否则将获取到一个<code>_HashedSeq</code>对象(<code>make_key</code>)，这个对象的职责就是保存整理过后的参数列表，并在初始化时只计算一次哈希值，节省算力</li>
<li>在获取到键之后自然便是在缓存字典里找一找有没有对应的值，如果没有的话就会默认到<code>sentinel</code>，然后运行函数并将键值一并存到<code>cache</code>字典里，否则就返回缓存过的值。由于是第一次调用，4不在缓存中，所以去运行原函数。</li>
<li>原函数调用了<code>cached_fib(3) + cached_fib(2)</code>，值得一提的是这里会先在当前命名空间下寻找<code>cached_fib</code>，所以找到的这个函数其实也是<code>CacheWrapper</code>的实例而非原来的函数。按照运算法则先运行<code>cached_fib(3)</code>，3不在缓存中，运行原函数<code>cached_fib(2) + cached_fib(1)</code></li>
<li>一样的先运行<code>cached_fib(2)</code>，2也不在缓存里，所以运行函数得到1，并将2和1都放入缓存；再运行<code>cached_fib(1)</code>，一样在缓存内找不到，运行原函数得到1，于是1和1的键值对也被放到缓存里</li>
<li><code>cached_fib(3)</code>运行后结果为2，所以3和2键值对也被保存到缓存中。接下来运行<code>cached_fib(2)</code>根据缓存获取到1</li>
<li>所以<code>cached_fib(4)</code>的结果是3，也被保存到缓存中并返回值，最后打印出来3</li>
</ol>
<h3 id="装饰器装饰装饰器装饰装饰器装饰装饰器……"><a href="#装饰器装饰装饰器装饰装饰器装饰装饰器……" class="headerlink" title="装饰器装饰装饰器装饰装饰器装饰装饰器……"></a>装饰器装饰装饰器装饰装饰器装饰装饰器……</h3><p>这是一个迷惑行为，灵感来自<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1je4y127nL">这里</a>，我们先来看一个简单的例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">nest</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        <span class="keyword">return</span> func(func(*args, **kwargs))</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"><span class="meta">@nest</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">say_hi</span>(<span class="params"><span class="built_in">any</span></span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;----\n<span class="subst">&#123;<span class="built_in">any</span>&#125;</span>\n----&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(say_hi(<span class="string">&quot;hi&quot;</span>))</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">----</span><br><span class="line">----</span><br><span class="line">hi</span><br><span class="line">----</span><br><span class="line">----</span><br></pre></td></tr></table></figure>
<p>把这个装饰器展开，实际上就是<code>say_hi(say_hi(&quot;hi“))</code>，而每一次<code>say_hi</code>都只是把字符串外层套上了一层线，所以两次自然上下都有两排线。我们可以把事情搞得更好玩些，我们让<code>nest</code>来装饰”自己“：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">nest</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;[0]nest inner <span class="subst">&#123;func.__qualname__&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> func(func(*args, **kwargs))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;<span class="built_in">id</span>(inner)=&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;<span class="built_in">id</span>(nest)=&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@nest</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">nest</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;<span class="built_in">id</span>(func)=&#125;</span>, <span class="subst">&#123;func.__qualname__&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[1]nest inner&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> func(func(*args, **kwargs))</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;<span class="built_in">id</span>(nest)=&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line"><span class="meta">@nest</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">say_hi</span>(<span class="params"><span class="built_in">any</span></span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;----\n<span class="subst">&#123;<span class="built_in">any</span>&#125;</span>\n----&quot;</span></span><br><span class="line">    </span><br><span class="line"><span class="built_in">print</span>(say_hi(<span class="string">&quot;hi&quot;</span>))</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">id(nest)=1921889762560</span><br><span class="line">id(inner)=1921889762704</span><br><span class="line">id(nest)=1921889762704</span><br><span class="line"></span><br><span class="line">[0]nest inner nest</span><br><span class="line">id(func)=1921889762560, say_hi</span><br><span class="line">id(func)=1921889762848, nest.&lt;locals&gt;.inner</span><br><span class="line">[1]nest inner</span><br><span class="line">[1]nest inner</span><br><span class="line">[1]nest inner</span><br><span class="line">----</span><br><span class="line">----</span><br><span class="line">----</span><br><span class="line">----</span><br><span class="line">hi</span><br><span class="line">----</span><br><span class="line">----</span><br><span class="line">----</span><br><span class="line">----</span><br></pre></td></tr></table></figure>
<p>来看看这个程序干了啥：</p>
<ol>
<li>定义了一个<code>nest</code>函数，使得被装饰后的函数<code>func</code>调用<code>func(x)</code>等同于<code>func(func(x))</code></li>
<li>打印出<code>nest</code>变量指向的对象的id (<code>id(nest)=1921889762560</code>)</li>
<li>又定义了一个一模一样的<code>nest</code>函数，但是这次用刚才定义好的<code>nest</code>装饰，这里把最上面的<code>nest</code>函数称为<code>[0]nest</code>而被<code>[0]nest</code>装饰的<code>nest</code>函数称为<code>[1]nest</code></li>
<li>被装饰的<code>[1]nest</code>现在虽然还叫<code>nest</code>，但是指向的对象经过装饰已经变成了<code>[0]nest.&lt;locals&gt;.inner</code> (<code>[1]nest = [0]nest([1]nest)</code>，而<code>[0]nest</code>返回的是它的局部变量<code>inner</code>)</li>
<li>打印出现在<code>nest</code>变量指向的这个对象的id (<code>id(nest)=1921889762704</code>)，可以看到现在<code>nest</code>变量已经指向<code>[0]nest.&lt;locals&gt;.inner</code></li>
<li>在空行后的输出都是在第20行装饰的时候打印出来的。把语法糖还原，变成<code>say_hi = nest(say_hi)</code></li>
<li>这个<code>nest</code>指向的是<code>[1]nest</code>，而该函数被<code>[0]nest</code>装饰，也就是说原代码可以理解为<code>say_hi = [0]nest([1]nest)(say_hi)</code>（还是把语法糖写成原来的模样）</li>
<li>刚才已经知道<code>[0]nest([1]nest)</code>返回的是这个<code>[0]nest.&lt;locals&gt;.inner</code>函数，也就是说可以进一步简化成<code>say_hi = [0]nest.&lt;locals&gt;.inner(say_hi)</code></li>
<li>调用这个局部函数打印出来<code>[0]nest inner nest</code>，然后根据代码返回<code>func(func(say_hi))</code>，这里<code>func</code>就是<code>[1]nest</code>，所以可以理解为<code>say_hi = [1]nest([1]nest(say_hi))</code></li>
<li>根据运算法则先运行<code>[1]nest(say_hi)</code>，打印出<code>id(func)=1921889762560, say_hi</code>，并返回一个局部函数<code>nest.&lt;locals&gt;.inner</code>，这里记作<code>[0]inner</code></li>
<li>这个函数又被传给<code>[1]nest</code>，而这次打印出<code>id(func)=1921889762848, nest.&lt;locals&gt;.inner</code>，也返回另外一个局部函数并将其赋值给<code>say_hi</code>，这个<code>say_hi</code>最终指向的函数则被记作<code>[1]inner</code>，两个函数除了闭包的<code>func</code>函数指向的对象不同以外并没有任何区别</li>
<li>接下来运行<code>say_hi(&quot;hi&quot;)</code>，根据刚才的信息，可以被理解为<code>[1]inner(&quot;hi&quot;)</code>。而在<code>[1]inner</code>里，先打印出<code>[1]nest inner</code>然后返回<code>func(func(&quot;hi&quot;))</code>，而这个<code>func</code>闭包指向的正式<code>[0]inner</code>函数</li>
<li>也就是说可以理解为<code>[0]inner([0]inner(&quot;hi&quot;))</code>，一样的先运行<code>[0]inner(&quot;hi&quot;)</code>，打印出来<code>[1]nest inner</code>，然后返回<code>func(func(&quot;hi&quot;))</code>，这次<code>func</code>终于指向了原先的<code>say_hi</code>函数，也就是说现在原代码可以理解成<code>[0]inner(say_hi(say_hi(&quot;hi&quot;)))</code>，也就是将套了两层线的<code>&quot;hi&quot;</code>传给了<code>[0]inner</code></li>
<li>一样的操作，把<code>[0]inner</code>化为两层<code>say_hi</code>嵌套，也就是说整个表达式(<code>say_hi(&quot;hi&quot;)</code>)就是被套了四次线的<code>&quot;hi&quot;</code></li>
<li>打印出这一长串字符串</li>
</ol>
<p>而如果我们在加上嵌套装饰器，就可以让套的线的层数成指数级增加</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">nest</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        <span class="keyword">return</span> func(func(*args, **kwargs))</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"><span class="meta">@nest   </span><span class="comment"># 16层线</span></span><br><span class="line"><span class="meta">@nest   </span><span class="comment"># 4层线</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">nest</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        <span class="keyword">return</span> func(func(*args, **kwargs))</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line">    </span><br><span class="line"><span class="meta">@nest   </span><span class="comment"># 65536层线</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">nest</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        <span class="keyword">return</span> func(func(*args, **kwargs))</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"><span class="meta">@nest</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">say_hi</span>(<span class="params"><span class="built_in">any</span></span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;----\n<span class="subst">&#123;<span class="built_in">any</span>&#125;</span>\n----&quot;</span></span><br></pre></td></tr></table></figure>
<p>虽然没啥用，但是很烧脑，很迷惑。规律就是每多一个嵌套装饰器，线的层数就平方；而每多一层，线的层数就等于2的现有线数次方，比如这里就是 2^16 也就是 65536 层线。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://www.fdxblog.tk">Fed_Dragon</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://www.fdxblog.tk/2022/11/28/Python-%E8%A3%85%E9%A5%B0%E5%99%A8%E8%AF%A6%E8%A7%A3/">https://www.fdxblog.tk/2022/11/28/Python-%E8%A3%85%E9%A5%B0%E5%99%A8%E8%AF%A6%E8%A7%A3/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://www.fdxblog.tk" target="_blank">FdxCaupona🍁</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Python/">Python</a><a class="post-meta__tags" href="/tags/%E8%A3%85%E9%A5%B0%E5%99%A8/">装饰器</a><a class="post-meta__tags" href="/tags/functools/">functools</a></div><div class="post_share"><div class="social-share" data-image="/img/cover1.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/12/03/Python-def%E5%85%B3%E9%94%AE%E5%AD%97%E7%AB%9F%E7%84%B6%E6%98%AF%E8%AF%AD%E6%B3%95%E7%B3%96%EF%BC%9FCode-Object%E8%AF%A6%E8%A7%A3/"><img class="prev-cover" src="/img/cover6.webp" onerror="onerror=null;src='/img/default_cover.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Python def关键字竟然是语法糖？Code Object详解</div></div></a></div><div class="next-post pull-right"><a href="/2022/11/21/Python-%E6%8F%8F%E8%BF%B0%E5%99%A8%E6%B7%B1%E5%85%A5%E7%AE%80%E5%87%BA/"><img class="next-cover" src="/img/cover5.webp" onerror="onerror=null;src='/img/default_cover.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Python 描述器深入简出</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/11/21/Python-%E6%8F%8F%E8%BF%B0%E5%99%A8%E6%B7%B1%E5%85%A5%E7%AE%80%E5%87%BA/" title="Python 描述器深入简出"><img class="cover" src="/img/cover5.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-21</div><div class="title">Python 描述器深入简出</div></div></a></div><div><a href="/2022/11/18/Python-Metaclass%E4%B8%8E%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B/" title="Python Metaclass元类与使用案例"><img class="cover" src="/img/cover5.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-19</div><div class="title">Python Metaclass元类与使用案例</div></div></a></div><div><a href="/2022/12/03/Python-def%E5%85%B3%E9%94%AE%E5%AD%97%E7%AB%9F%E7%84%B6%E6%98%AF%E8%AF%AD%E6%B3%95%E7%B3%96%EF%BC%9FCode-Object%E8%AF%A6%E8%A7%A3/" title="Python def关键字竟然是语法糖？Code Object详解"><img class="cover" src="/img/cover6.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-03</div><div class="title">Python def关键字竟然是语法糖？Code Object详解</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.webp" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Fed_Dragon</div><div class="author-info__description">一些Python的小技巧和整活</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">4</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://space.bilibili.com/509754182"><i class="fa-brands fa-bilibili"></i><span>关注我！</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/FedDragon1" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://space.bilibili.com/509754182" target="_blank" title="Bilibili"><i class="fa-brands fa-bilibili"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">博客试运行！页面因为性能原因有可能会卡顿<br>主域名：<a href="https://www.fdxblog.tk">www.fdxblog.tk</a><br>备用域名：<a target="_blank" rel="noopener" href="https://blog.fdxblog.tk">blog.fdxblog.tk</a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A3%85%E9%A5%B0%E5%99%A8%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">装饰器有什么用？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E6%97%B6%E5%87%BD%E6%95%B0%E8%BF%90%E8%A1%8C%E6%97%B6%E9%97%B4"><span class="toc-number">1.1.</span> <span class="toc-text">计时函数运行时间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%99%E5%87%BD%E6%95%B0%E6%B7%BB%E5%8A%A0%E5%B1%9E%E6%80%A7"><span class="toc-number">1.2.</span> <span class="toc-text">给函数添加属性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9B%B4%E9%AB%98%E7%BA%A7%E7%9A%84%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="toc-number">2.</span> <span class="toc-text">更高级的装饰器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#functools-wraps%E8%A3%85%E9%A5%B0%E5%99%A8%E8%A3%85%E9%A5%B0%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="toc-number">2.1.</span> <span class="toc-text">functools.wraps装饰器装饰装饰器(?)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E4%B8%AA%E8%A3%85%E9%A5%B0%E5%99%A8%E5%B5%8C%E5%A5%97"><span class="toc-number">2.2.</span> <span class="toc-text">多个装饰器嵌套</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A3%85%E9%A5%B0%E5%99%A8%E4%BC%A0%E5%8F%82"><span class="toc-number">2.3.</span> <span class="toc-text">装饰器传参</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E4%B9%9F%E5%8F%AF%E4%BB%A5%E8%A2%AB%E8%A3%85%E9%A5%B0"><span class="toc-number">2.4.</span> <span class="toc-text">类也可以被装饰</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E4%B9%9F%E5%8F%AF%E4%BB%A5%E8%A2%AB%E5%BD%93%E4%BD%9C%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="toc-number">2.5.</span> <span class="toc-text">类也可以被当作装饰器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A3%85%E9%A5%B0%E5%99%A8%E4%BD%BF%E7%94%A8%E9%89%B4%E8%B5%8F"><span class="toc-number">3.</span> <span class="toc-text">装饰器使用鉴赏</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A3%85%E9%A5%B0%E5%99%A8%E8%A3%85%E9%A5%B0%E8%A3%85%E9%A5%B0%E5%99%A8%E4%B9%8Bfunctools-wraps"><span class="toc-number">3.1.</span> <span class="toc-text">装饰器装饰装饰器之functools.wraps</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A9%BA%E9%97%B4%E6%8D%A2%E6%97%B6%E9%97%B4%EF%BC%8Clru-cahce"><span class="toc-number">3.2.</span> <span class="toc-text">空间换时间，lru_cahce!</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A3%85%E9%A5%B0%E5%99%A8%E8%A3%85%E9%A5%B0%E8%A3%85%E9%A5%B0%E5%99%A8%E8%A3%85%E9%A5%B0%E8%A3%85%E9%A5%B0%E5%99%A8%E8%A3%85%E9%A5%B0%E8%A3%85%E9%A5%B0%E5%99%A8%E2%80%A6%E2%80%A6"><span class="toc-number">3.3.</span> <span class="toc-text">装饰器装饰装饰器装饰装饰器装饰装饰器……</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/12/03/Python-def%E5%85%B3%E9%94%AE%E5%AD%97%E7%AB%9F%E7%84%B6%E6%98%AF%E8%AF%AD%E6%B3%95%E7%B3%96%EF%BC%9FCode-Object%E8%AF%A6%E8%A7%A3/" title="Python def关键字竟然是语法糖？Code Object详解"><img src="/img/cover6.webp" onerror="this.onerror=null;this.src='/img/default_cover.jpg'" alt="Python def关键字竟然是语法糖？Code Object详解"/></a><div class="content"><a class="title" href="/2022/12/03/Python-def%E5%85%B3%E9%94%AE%E5%AD%97%E7%AB%9F%E7%84%B6%E6%98%AF%E8%AF%AD%E6%B3%95%E7%B3%96%EF%BC%9FCode-Object%E8%AF%A6%E8%A7%A3/" title="Python def关键字竟然是语法糖？Code Object详解">Python def关键字竟然是语法糖？Code Object详解</a><time datetime="2022-12-03T11:27:05.000Z" title="发表于 2022-12-03 19:27:05">2022-12-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/11/28/Python-%E8%A3%85%E9%A5%B0%E5%99%A8%E8%AF%A6%E8%A7%A3/" title="Python 装饰器详解"><img src="/img/cover1.webp" onerror="this.onerror=null;this.src='/img/default_cover.jpg'" alt="Python 装饰器详解"/></a><div class="content"><a class="title" href="/2022/11/28/Python-%E8%A3%85%E9%A5%B0%E5%99%A8%E8%AF%A6%E8%A7%A3/" title="Python 装饰器详解">Python 装饰器详解</a><time datetime="2022-11-28T10:23:30.000Z" title="发表于 2022-11-28 18:23:30">2022-11-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/11/21/Python-%E6%8F%8F%E8%BF%B0%E5%99%A8%E6%B7%B1%E5%85%A5%E7%AE%80%E5%87%BA/" title="Python 描述器深入简出"><img src="/img/cover5.webp" onerror="this.onerror=null;this.src='/img/default_cover.jpg'" alt="Python 描述器深入简出"/></a><div class="content"><a class="title" href="/2022/11/21/Python-%E6%8F%8F%E8%BF%B0%E5%99%A8%E6%B7%B1%E5%85%A5%E7%AE%80%E5%87%BA/" title="Python 描述器深入简出">Python 描述器深入简出</a><time datetime="2022-11-21T08:17:46.000Z" title="发表于 2022-11-21 16:17:46">2022-11-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/11/18/Python-Metaclass%E4%B8%8E%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B/" title="Python Metaclass元类与使用案例"><img src="/img/cover5.webp" onerror="this.onerror=null;this.src='/img/default_cover.jpg'" alt="Python Metaclass元类与使用案例"/></a><div class="content"><a class="title" href="/2022/11/18/Python-Metaclass%E4%B8%8E%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B/" title="Python Metaclass元类与使用案例">Python Metaclass元类与使用案例</a><time datetime="2022-11-19T03:48:32.000Z" title="发表于 2022-11-19 11:48:32">2022-11-19</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 By Fed_Dragon</div><div class="footer_custom_text"></div><div id="footer_site_ontime"><p id="ontime_value">2022/10/29</p></div><div class="framework-info"><a target="_blank" rel="noopener" href="https://hexo.io"><img src="https://img.shields.io/badge/Framework-Hexo-83855d?style=flat&amp;logo=Hexo" alt="Framework: Hexo;"/></a><a target="_blank" rel="noopener" href="https://butterfly.js.org/"><img src="https://img.shields.io/badge/Theme-Butterfly-83855d?style=flat&amp;logo=data%3Aimage%2Fpng%3Bbase64%2CiVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAIy0lEQVR42u2bdXjbShbFs8y8%2B88yMzMzMxVMMZTrKEyPw4%2BfU2ZmBttlbh8zMzPaLtetPTu%2FzytVcSJbkpWH%2FuN%2B32junXvPOYK5kpMKIcRr2soClAUoC%2FCaF6AsQFmAMZ3Rz%2Flb58f8DdNuDrTO3xhsW9UY7Fr%2FsVcLSbjACW5whCucBQKEzl2luP%2FuEu7f%2FyXP%2Fio8%2F%2FAKr6f%2BpG9szwv%2Bc1Zc%2FEohDFYwgx0OcMnnB2e4V3h9DWkmzJh3eDgTaJm7ZUjb7ne%2B3EiDCWxgNMsH7hXuvwzhwJKhqr9u8p2h82OffqmJgwEsYLLKA%2B4VnmHjs%2F0cf5CX%2F39GCm%2FgbOFx1UjCvoGF%2BHcwGzx31RkvFXlqg2EgbGAGOxzgAqf8GLhXBBqmPKlN%2FnWo8DUvEf5pjwr%2FrGf7WGXkduGrmy2Tjeib6I%2F%2FEP766Te82OSpSW0dFrCBEaz5%2BOEENzhq8XCvGH3hmnM48LprhX%2FKQwQXtcoLrxaeytY%2BxX3Bs46N7oh%2FbbCJU4Na%2BtpgAZMZ7HCEK%2BvgXhHYLd7qDzamldWPidHLnifItFV27hKeIWN0t0QoG%2BqM%2FXawyJObGmo9aoPBCmY4whXOcK8gcc26Z6dWx5ICC69NiODc58wnnfm08NbO0rYaz39HZkf3xH%2FgNHlyklvdoqlJbbM44QQ3lSectUaoOpb4lerAlGhSjFpi8Wro2C7UHcU7bFzGyduBXORUn9zUsoINLnDSc4SzJsCQleINcvJZHHobt%2FoFEZhjQYTIbewMORFcVafUbku1SGdkz4SuCf8yIoqPGP0cOchFTnJTwywesMMhnxdc4awJgMnJ2TjzTdmYFCMWPmdehAl3Cc%2B%2F%2FLkH44hzD%2BcT7O3qTU3qmfTFfPLM4csXiBzkIie5zeIAM9gH4gRXcvcVIJr6M04jG7viBeGfbVKE3juE55%2B53kH23Rv0hCTJiLRd%2BQIwh08%2Fx1pykIucZmqDEayFuMC1nwDKJvEW6cwUWli1PiFC858zJ8IlNwr3n%2F4p3H8bLoIXxH6s1pkxY8abJNH75Jn%2BqTrHmDl86hxrWEsOcpmoCTYwFiQPR7j2EwBT4slHCCqsXlKMWW7uavC1LNN6BH2dSFfEJQlvU48Z93b3evUx6l5PDjNnHUxgK4YfjobfA6pjqf0EmTGUNvNs8PjPzN0KLfO26mq9TpK%2Bubej9weYHN%2FW1tb2etVPLGtYa%2BZeB4tZ3HAsIEBisflE2k5RuG%2BY%2FACvnrSggkZGdxXUSuJxTI7r9c0OsaxhbaF9ndpW8cLRUAAlluy2mFDrG0Yvfb5gx0jz4gu0HtcEOD%2FySUk%2BK01M6pz0KXWeGGILdXjUoqYdrHA0vgLiyZEE2bXwOuOHpHd85P%2B7woK12tn%2Bd%2BgZTD3GRwyxRg85apSCEY5GAmgdYak2dtUAt8XUh%2BniBB0dtf7147989fff%2Fr3AGDOHjxhi8y93cjqBDY6GAtSvf%2F5jBDliUSnEyr6dpK9%2Bbu419MzFS1y%2F%2B%2FMNf%2FjO7wXGmDl8xOg7OXKQyylccDQSgIPXyaBjBDplCtvmCoTIvZOzt3vd1WnIDvnVnwXGmDl8xBDLGtY6iQVucDQQQHsO7CHYaYMMr6K%2B5kXCO2RUv%2B92zOEjRiPusMGt6O8CSizxb4IHyU4p655NVI5pP5QvAHP4iBms%2BnArKgBWE010ygUn7BSp2XxQ1G09LOp3HBUNu46Lxr1p0bz%2FpGi5IiNarxICGz9xq548xpzmJ5Y1rCUHuchJbpvkT8DJ0i9D41c%2B886a%2BMG%2FVsdT4ZpY8kx5%2BVworUc%2BkJplOzmmdsuhsAR3J0CbL89I0FnAF7WmfSfFuIvX5QvAHD5TOahFTWqDASxgAhsYwQpmsMMBLo7%2BNNa4J72o5cpsFjBWrVaexfCUHcLz539q5Bkzh89OTrCAadB%2FG6zbefQjTftPPUJRO9a4%2B3juPWLiJjEqfI7w%2FvU%2FAmPMHD5i7OYHGxgHRYCGPUddzVdk0nbBtchLtiaeyglwySoR7pglwu0zMcbM4SOGWNsigBGsjgog78321iuztkGxVt6np1vmngWQ1htzmp%2FYUuuB2REBGnan%2FS0lgMHqth%2BBWM42PgfhgQyfFseaUmqCGewlC9B8IHOYhCXe95opK%2B43FACfFlvi8wADe0kCNO48FiyJ%2FN50%2F2Zk9lWGAuDLjydHKRjgYFuApt3HGx0685pV9W7U3fcLM5h6jE%2BLdehKgIN9AfYcV%2BwUbdh5zOAN8QUR7porNMIXrziMqcf4iBloLTntYIGDbQEadh8babEgbatxL778PohqVhVZ%2FyimmyPGcD25reKBg20BlE3i3aY7viuFqNt2pPDLyOwr%2Bwowaes6TDdHTKEc1KCW6Q4RDiXtAk170zea6c1rtx4u%2FiU5sqGvADP2DMF0c8QUy0MtU%2B8eYC95G2zcdeQfxZ70NZtShUFjG5%2FnHtc3PllZ4PUYY91zgNii%2BahZbIcAuyOdYPO%2B9C39z3pGXo6Hzb%2BLL7lDf%2Fbp%2Fa9X8zPW%2BYg1nRcMYMnHB2bHWuGG3Qc%2FKF8%2F06e3uBOiOtfXm7aqyduERrJztqiZcUD7aYwxc6qfWAu5wQImjTxYweyUANqO0Lj3RNbWRwm2v%2B75pwleuv7x%2FPzMqX5iWWPnYwwYwer863AJ3wuVpXf1vfyn7xqfn5s5fQxrSvzu57wANdFUlR1QVfJjh0bu0rXPGuXHp8axxk4tMA7eB5EtqffLIk9Zu%2FwTudffzjmiakLs9sC8G99rlB8fMcSyhrVWaoENjIMlgP4PKU6ZvvyX3S3o9pRpe79ltgaxrGGtlS%2FOYHtR%2Flxe2Zj4hdkrQVl869a2tt1vtFqDNaw1e%2BbB9KL%2Bv4ASTX1fFk4XvB9jyaltbeL1dmuwlhxFyKfB8pL8w4QST7kkgAcM9ubziHHCyGVA%2FgEwvKT%2FMcJZUjYd%2BlB47cEP1EYTv%2BT7vBJNfAOfk0ZOclODWtSkdvlfZsoClAUoC1AWoCxAWQDb9j9N63hK2EtncwAAAABJRU5ErkJggg%3D%3D" alt="Theme: Butterfly;"/></a><a target="_blank" rel="noopener" href="https://vercel.com/dashboard"><img src="https://img.shields.io/badge/Host%20By-Vercel-83855d?style=flat&amp;logo=Vercel" alt="Hosted By: Vercel"/></a><a target="_blank" rel="noopener" href="https://dashboard.4everland.org"><img src="https://img.shields.io/badge/Host%20By-4everland-83855d?style=flat&amp;logo=image%2Fpng%3Bbase64%2CiVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAMIUlEQVR42u2aW6xc11nHf2vt69zPzcfH8QU7J3Ecx5c4OEkTRCgIKhpVQUFBRVDRB64KttIGIiRAgj4hkbQVt0rwglKQqj60aROQlTaECEMoTus6SW1iu3Z8Ofa5zpkzlz37vhYPa2%2BfU4mHgOI2UWakpT2zZ885%2B%2Fut7%2FL%2FvhmhteaD%2FJB8wB8jACMAIwAjACMAIwAjACMAIwAjACMAIwAjACMAH8CHTQey45ACuYbMgkxBGoH2wHYhz8CqQtwHbxyiIWQJYEGagnRBOhAOABtyBQoQNkQKvDFzfphzsDNgd6XJR9sDEC7kEtZi8DxYGHJeSY7PjPHaW23i5Ri0gGFurtkxBhc7MFYBIeD8GkxVzTW2hDCDxSEcmIaVEBoeaAVni%2BvunYFvXoUxHxLgYg%2Fsm07Yhjzh1iDgiFXjt5otak4FmuPmxjNgqzY3b7kwSOFqh1e7MU97Nl9L1PswBLQGATgODHv8WbfHeWXzaelS86vm%2FTCCQQTD4hilZmfGK1B3eFAonrvS4VtJzkHfNp%2B5OSFwM%2F6oC0nA7FrEP0WCPbVxcOuQA1kOuQANSGGuF4VxeQ5Sw5YG1D3IF7h%2FbsCpXs5TEzWeseX7wAMsAemQ3wsyTic%2Be8a2glczBiPNUWBiuFyWAHvDaynAd%2BC%2BrXBgCjx4eqnPP6%2BEbHffZW94VwAICbYDKA4Merw6SHnGmsBrbDKJMNdmURiPAGmBlGBJ87w03BEYShpQsKMJP7MDtvg8fKnNuZUhj9c9cCQo%2FaMGIMCyIA%2BpB2s8Oxjyeih4wN0MXsOAMdtt%2FpMqYLF%2Bav1YeIIQYGEMtC3jGQ0XHtgKsw38OOZvFvp8b2HIz3vWehj9cHOAMLsnNGNpwpEg5GgkmKYC1QkQPmi5bqGwzE7nxcbK4rwW6zAsYXZUCnAs4%2BZlAVCY9w7PmM9e6HJXAseweC5RfN61OW7JwrtuNgDLBTlkUxJzNEo4EsG4roErjVaQTVB5AcAy1ilhXktRxK80xmux7gH2hvwgAZ0ZcFIar6AIkT2T5oIog7mARzsBj9o2z49V%2BQsteFmK%2FxuIdwRACLBskHBHsMxnhwE%2FG4FH1WRt5Rgwwi9ygWtiXlEYr424UsU5XQglXe5uIcLyDUchwCm8xZFQcSFVsNOG5dCIo5YPwwze7vHIfJdHbIdXMs3T0uIbtiSzCsj6%2FwWgTEaCmUzxq8ESn4pStkUx6Ao4DYhjzlQbjDk%2BZ4OYMWuCdnuOL3cHKFyE7Zkk6Hrg%2BuAWoCx7QxiUClRBkhtBFETQi6ETwiCBfgLdGJQku38Hh3e1%2BMiJeTrbm2w900He2mTaltinVviw1Hz4%2FDKDQc7f3znJV5XmFVe%2BUwCi2B3BeB7xMWGxL%2BlzJBuyaNc512gwP9XitJzgerLCC3qImN7PPrfOZP9N3m77fPlKBt2OCQdfgfSMV1gWuK6B4TgmwZUpONeQ5satSSAtjlEKvcjI2sUBSBuaNs%2FOKdy4xtHLmnzNZalRRQ4zfmrbJi7Ymtlhxq%2F3%2Bzz%2B5gofSxSnGw7frlgcq1icuKE%2FdAlAGh%2FUOVUFHxWST9gpY%2F40E26NTCU8K6f4c8%2FmgHBQeOxFMNR1mqLOQ8CyusDZxhYWKhZcrcCiBeOF0WUMaw1KGbEjingvs1yujXtnedFHFDdnSZMQfRtqLjQsWMlg2xTJdwOa3Zj88BaWrwU4fcW3Dt1C78qAwW0VPnMPrL54hXoYcuhSyIH5mMNVj7vynC%2F2Ep6XNicFIHRH17OT%2FGGueByPqpSELPLHzp2sodlPk2VWOZ2vcp8UrNJgQQeMiSa36oxrtIjUeV4kZ96ukQYRvLACsQ2tCmgb6g1ojYHvGy9wXANHiB8EEGcQJNAfwlIAlzuwFhn3z2K4asN8FaZ9ON3msUmfMMzp7x%2Fnx2PF9bWYbGeD3eMec%2Bd6eNtqbG6HnDjVJmw4bLXgk0Jz10wVqeDYfy7xJyI%2FqZ9Xb%2FKyvJ0LYoigRpuAVPfZzhgdeYix%2FF%2BJyVkiZkrsoUOXKruYEYoIB0dd5iJtLiFZtjyIczgWgqxArQqWY5ZfJMkyJDbmgBJAmEI%2Fgm5k8sFaBP0AvpvAGQ%2BszHSnkz6%2FEWRcSxWJ0ogwZ9CPcXc0YJAiBil116KjNNmkzxSC4U9uZvL7PRYqFjuvB9z7RpuXbWzO4bMPjwkUi0KQakjJiYWL1BewGLJGFYmHJWyaTFFVJzmvJ5iSd1NFo8mLqFLQt6DWBL8KM5thdQ1OXzRJLs1NC5wVnWBZAVIMhBRzfvsU3LsLlgOY70A7gCsprOWmzCoFaU6eKFKlafgWYeaQVm3qlsDKNXbdYWItoe9IeklO35bM3DPFvpUQ%2B5tXuX54Ez9hyzv4fa3466zLH6gESyjmLc28vZuv4LCkV2iIaU6KOo%2BJhJ62UGimCOhoG1v3sXWfATUGdh2ur8K%2FpdBqgFTmRrWGLIM4NbucCbNS1ktfCSAXoKTJBbk2eSFQsA24M4IrddhWg%2BNzrO6dpBFlcL5HfXcT3fIZn%2FTZO%2BlyeT6ifrZDtx1younw8ck6B08scs%2FWCoeUZn5Pk2dvbfKPdpGIjqiQI0mfX1AeH9ewX1ziCafJFgHHtUZ7iqp0eVMO2U0NZd1FhYQH6DNHi0Nyih3K4hsnV8DW4JaSvkxoljmvitouhSkCJQCJAZZhIJSiqRRHXQXNHB4dh9ldYEvu7ycED22lP9tnuWmxH%2FjeYsjcpR6eL1jMUh704BNRxIdCjbU64JX5Hk%2FsaPHizgZnFWCXikTYIF2%2Brut8PVmDuM2dFjyZhXxEaf5ShyAdLhNwypnhat1j33CVxfoE1Gf56e7rHP9OD7oBtJpm51y9XglytWEVRub8oPjJSgBFVXaKRJkVoTNU8O9n4dUl2HMLjYHEe%2B0K0cFJ7tCa%2B04usrMXIzsxvwSMS0F3h8%2Frec6nOyFfazosRMCYZ8Kx9r8KIWVu2K7z38LiNy0JXotPBsv84jDnkVDyY%2BoK2HVIchb8izhenUZfcHfWYu8tVVzcG4JHxDFuHPOKY%2FOGMk5wQ9qWequcB1A0RFqilMbvRfyy0tTqPonCCCkByVAzO%2Bxw37TPlktDhm9FjCUarvUKmaw5t73JX2XwpVzx1uYaLMcm%2FEQB%2FIbO04EmPwdZG9IA8hqkA0iHIJpGk7vjEK%2BAVWU2zTg6HHI0iJFUQVugLGOwPw5UTdyrQt2leVHurXXZW%2FYBN16XHqDXJXSqzKJol8tq4dvw6jxcGxiQQQrneyaHTNX5j6bP5%2BYGfHVHw%2BiIhQAmfOhnEGTmuu1NEArGq%2B%2BkF9BGHeYKhOSC2%2BRTbpPP10Ke6HZ4dDBgp%2FYNqKjcTV2AKWJZWuvDEIrGiA06vZwXpArScnYgTblLtBnAxkX%2F8FYHrg5gmMDFvhFVt7T4l9sm%2BGyiOdaJCvBqvZt897pBbW5Kay5XN%2FNkmvGkgKdyiz8ahLSSBFzLyGCtjaFKGoBaGC%2FQhdy%2B0REWO1%2FueI7REYky5xNlVlz0CmdWYG4AqYDpJsdmJ%2Fhcy%2BOlmg3nu8bjxA9jIJKnRrM7FZ5ujDNblXzGSiBcgnhgfFsok9G0Wr8ptaE0lksVK9fG08pzaWF0rIyrn5g3o%2BxAc6xe4aHdkzzcdHmpF0OU%2FwgmQoIb%2Br4tLf50rMXdTZuX8jaEa8ZwWQxPwAgYCqNL3Z8X%2FUGujDekxc6XoaGAdmiMfzsgmmzw2%2BMVHnYEx6PMAHpPDEWV6SJfb03zc60Kv6M7JP1FyBOT2SmmPWVjVILYOA9QRdDemBsA3%2B%2FAtxdgNeMrt0%2Bxe6rC3%2BkNM8b33FQ40%2BBW%2BdtGhdvp8V%2FBEkQDkxxFUX4sud4IlSDkhqSoi%2Bx%2BahFOLkMIv7JrnMdcwdUyXN67X4xo49KZ5sqmGT5UkTzVu85c2C00xsap74anpT7Qwrj8d%2BbhzCr%2FsHeGgxMVvhSm6yXzffHlqBCmxrg%2Bz1hwWxbyu%2BGAN%2BLQKLxS6pZTXcuCYQoLfZau9%2FliJ%2BFA3eXXGg5vCN5ZSXvPfDN0wxmKjI8kdj2%2BECZ8gZwH51bYWWtwaGqKQ0ECmab%2F2kWea9SJIs0LrkVYdyCOTVLUN3GnxOjn8qMfSIwAjACMAIwAjACMAIwAjACMAIwAjACMAIwAjAB80B7%2FA4t1%2F6lyzbV6AAAAAElFTkSuQmCC" alt="Hosted By: 4EVERLAND"/></a><a target="_blank" rel="noopener" href="https://github.com/FedDragon1/FedDragon1.github.io"><img src="https://img.shields.io/badge/Source-Github-83855d?style=flat&amp;logo=github" alt="Source: Github"/></a><a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-83855d?style=flat&amp;logo=image%2Fpng%3Bbase64%2CiVBORw0KGgoAAAANSUhEUgAAAHwAAAB8CAMAAACcwCSMAAAAMFBMVEX%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F9Or7hAAAAAD3RSTlMAESIzRFVmd4iZqrvM3e5GKvWZAAAE5UlEQVR42u1b24KFJgwUCBhAwv9%2Fbe%2FteoKMskjv87jLYUgYYhJxG4fzHHOuJ%2BTM7N22GDbwUbvIHMwqZsel3uJgt4A5Sn2I8jJ%2FOOoQjtf8b1jqMITNUur19EFRj9HPyeyoUyh%2BwuN1GsksNxtAvmX8Ds9SZuZAROSZOecKEIeNN7HLy8G1463n3P2FG%2BO21y6X6IEZxkd5wfXucpL0YA5%2F7bH9OTddcAvbmagUn3KH2XAVZJgdcLOZj8nRfIs7220YNrXTPNjvxuNALAhehj3vBBzSMZg0yG4FjJ8PkgwXewydz%2FEzG8Bg5SjRY6cfTtLfRAYjAUZ8WQwW%2Bjw3Yk%2BdYaXhXsHu8YbPcyN2sVsL3yxwEXu6dXp4tdyRG7t4IrYMxuzShLbPmPp2tbnDQJegJuaRP%2BY3wC9hex1G%2BqZnJcf34bumu7VOV%2FYp06P%2BxwJYJXjw9wXgRlbtn2kJs9bc8cefC07zlphutRCXGq5MZy23ZTsOiORRfLFEwRPBc%2BiIdiIyTwTvGq9Lx2F7li9V7O5y5j2f4tRu7846N87gy2ljVci%2BsbkZkwhXQ0ej9SubLqvObGH3plOdmXqCUaG1tNQmo14L7t6IQ6maV49ahimQQugkKog9KLLYel1zY3aruBG7VeGsIK3nCiAOrK%2BTE50Hf2ogPWmHacFyheB%2BnLEfOQzD9KOwJwpZ5aEq%2BWMi2j98YbubTtsO4jpftUboj6lLUKZIaKrTrOZ0H7aeCQwwPGgRlqAVJE5XAZk2jQ%2Fy3D%2FlviMHK79RK1XsykLdc9aKy2fyvCFxnMBfnfTu2rmE7QKffKVfphSl6y%2BYSy92hnR1JOrXvUDMD%2BogGk5nADmeuJXFNkUe%2BuT2iRMfIXTICawRkI9lnvR3Iv%2BfHAjOvSY4P37U%2FIOpzJvn3A4GGT9OLv3wKt1njqM2vOqfe3tPDh4sqWtWrtG2aZFVz%2BN4RZ87TzUBwag02VW02pDUrDxaSA6TCdWZ06lytKqhEtqFRwuSCZhGxcv3wbuc2dpWi6pgPFAxSiCtfpdJRHxOtW3TXGQi8izdBrv%2F0JFBXQmuEDtK7e%2FDpsNFAy4IEixYWmfqpaoDRbBf3ClGCHBHkLxmUCgCdlUIhefcWmGoRAblb3ywwh3Gt6BbMu7htQ3xoIgH7yKLjipR26Nh4%2F0LbdL0l2m7a9oiQbeDW9hTQ6hE3xvzxRzd7VOF2ygKW2E%2BEJmbVlgAY652OC1vAoInVdCmr0K5OtWy3PTWSIc74UsNPzrNfvNnGB5Wv%2BYAfQ4xvTdbbn2rn7v9tmMBtbLP6n8tdbwp4GmXljpeqUosTNfMSqVXxulafpfb4Usb%2BuV9XPzyHt8V4bXXFjRUyhDWXtjAjq9h9VUVJYsF7FZxx6e3uPhlreHbGFGxx7fvaYvD%2B%2FPmtRG%2Bqdyw6KrQxHZnzR3G9mhi473gCuYRe6FvmZ1w5YbZp%2B5pbyyQG7BPf58QCq7UMfsEvaIejliu1G%2FftLbK4WNXOUE7JIcb801I%2BH3u3MX%2BtHftt4p5IlTttQdJTFatlTiVx02h8Y3XKDnzL8j5WPA5h%2BqHrP6QRYPKgq9Y1n81Nf5FAG4GjSPa%2BTwoLabGcHExNYblIekVfrnc8k%2B9L5FWtBZClHub%2FbYMbu%2BH0RKD3VbD0M45y4k1Jw7f8fWPsLFGZr3MQTIAAAAASUVORK5CYII%3D" alt="Copyright: BY-NC-SA 4.0"/></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script type="text/javascript" src="https://yijuzhan.com/api/word.php?m=js"></script><script>document.getElementsByClassName("footer_custom_text")[0].innerHTML = `${str[0]} —— ${str[1]}`</script><script>let element=document.getElementById("footer_site_ontime"),startDate=new Date(element.innerText);function getTimeDelta(){let t=new Date,n=new Date(t-startDate),e=n.getFullYear()-1970,p=n.getMonth(),s=n.getDate()-1,a=n.getHours(),r;return[e,p,s,a,n.getMinutes(),n.getSeconds()]}function displayTimeDelta(){let t=getTimeDelta(),n;n=0===t[1]?`本站已经运行了 ${t[2].toString().padStart(2,"0")} 天 ${t[3].toString().padStart(2,"0")} 小时 ${t[4].toString().padStart(2,"0")} 分钟 ${t[5].toString().padStart(2,"0")} 秒❤`:0===t[0]?`本站已经运行了 ${t[1]} 月 ${t[2].toString().padStart(2,"0")} 天 ${t[3].toString().padStart(2,"0")} 小时 ${t[4].toString().padStart(2,"0")} 分钟 ${t[5].toString().padStart(2,"0")} 秒❤`:`本站已经运行了 ${t[0]} 年 ${t[1]} 月 ${t[2].toString().padStart(2,"0")} 天 ${t[3].toString().padStart(2,"0")} 小时 ${t[4].toString().padStart(2,"0")} 分钟 ${t[5].toString().padStart(2,"0")} 秒❤`,element.innerText=n}function startCountDown(){displayTimeDelta(),setTimeout(startCountDown,1e3)}startCountDown();</script><script id="canvas_nest" defer="defer" color="131, 133, 93" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>